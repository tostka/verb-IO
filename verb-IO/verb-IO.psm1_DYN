# verb-io.psm1


<#
.SYNOPSIS
verb-IO - Powershell Input/Output generic functions module
.NOTES
Version     : 2.0.0.0.0
Author      : Todd Kadrie
Website     :	https://www.toddomation.com
Twitter     :	@tostka
CreatedDate : 3/16/2020
FileName    : verb-IO.psm1
License     : MIT
Copyright   : (c) 3/16/2020 Todd Kadrie
Github      : https://github.com/tostka
AddedCredit : REFERENCE
AddedWebsite:	REFERENCEURL
AddedTwitter:	@HANDLE / http://twitter.com/HANDLE
REVISIONS
* 2:24 PM 4/29/2022 tuned to modern \module\module\module.ps1 with parallel public\internal dirs for included funcs.
* 3/16/2020 - 1.0.0.0
* 5:10 PM 3/15/2020 fixed damange from public conv (ABC->tor & tol)
* 6:30 PM 2/28/2020 added ColorMatch(), extract-Icon
* 4:37 PM 2/27/2020 Added Add-PsTitleBar()/Remove-PsTitleBar()
* 6:32 PM 2/25/2020 updated get-fileencoding/get-fileencodingextended, & convert-fileencoding - set-content won't take the .net encoding type, as it's -encoding param
* 8:57 AM 2/21/2020 added trim-FileList()
* 8:48 AM 1/3/2020 transplanted from incl-desktop: Expand-ZIPFile ; Get-FileEncoding ; Convert-FileEncoding ; convertTo-Base64String ; Get-Shortcut ; Set-Shortcut ; Find-LockedFileProcess ; Get-FsoTypeObj ; Get-FsoShortName
* 12:03 PM 12/29/2019 added else wh on pswls entries
* 12:36 PM 12/28/2019 updated load block, added: remove-ItemRetry
* 12:14 PM 12/27/2019 init version
.DESCRIPTION
verb-IO - Powershell Input/Output generic functions module
.LINK
https://github.com/tostka/verb-IO
#>


$script:ModuleRoot = $PSScriptRoot ;
$script:ModuleVersion = (Import-PowerShellDataFile -Path (get-childitem $script:moduleroot\*.psd1).fullname).moduleversion ;
$runningInVsCode = $env:TERM_PROGRAM -eq 'vscode' ;


# functions that aren't supported under PsV2 loads:
$Psv2PublicExcl = @('ConvertFrom-SourceTable.ps1','Test-PendingReboot.ps1') ;
$Psv2PrivateExcl = @() ;

#*======v FUNCTIONS v======

<# [Understanding a Windows PowerShell Module - PowerShell | Microsoft Docs - docs.microsoft.com/](https://docs.microsoft.com/en-us/powershell/scripting/developer/module/understanding-a-windows-powershell-module?view=powershell-7.2)
$PSScriptRoot This variable contains the directory from which the script module is being executed. It enables scripts to use the module path to access other resources.
Practical matter, it's the path to parent dir of the impmo'd .psm1 file
- it's only going to work for direct dot-source: . $PsScriptPath\function.ps1
    if the function.ps1 are stored within the .psm1 directory (or if using gci -recur, in subdirs below the psm1 hosting dir)
#>
#Get public and private function definition files.
# sub $PsScriptRoot with above $script:ModuleRoot
# when renaming to .ps1 for debugging, $PsScriptRoot doesn't eval as populated
if( $runningInVsCode){
    if($script:ModuleRoot){
        $inferredRoot = split-path $script:ModuleRoot ;
    } else {
        $smsg = "Unable to resolve module root location!"
        write-warning $smsg ;
        throw $smsg ;
        break ;
    }
}else {
    $inferredRoot = split-path $PsScriptRoot ;
} ;
# path-builder approach:
#$PublicFltr = [system.io.path]::combine($inferredRoot,'Public''*.ps1') ;
# with content excludes
#$public = get-childitem -path $PublicFltr -exclude *.tests.ps1, *profile.ps1 ;
#$Public = @( Get-ChildItem -Path $inferredRoot\Public\*.ps1 -ErrorAction SilentlyContinue ) ;
$Public = @( Get-ChildItem -Path $inferredRoot -Include 'Public', 'External' -Recurse -Directory -ErrorAction SilentlyContinue | Get-ChildItem -Include *.ps1 -File -ErrorAction SilentlyContinue | where-object {$_.Extension -eq '.ps1'} ) ;
# above is including breakpoint .xml files, include isn't properly filtering, post filter
#$Private = @( Get-ChildItem -Path $inferredRoot\Private\*.ps1 -ErrorAction SilentlyContinue ) ;
$Private = @( Get-ChildItem -Path $inferredRoot -Include 'Private', 'Internal' -Recurse -Directory -ErrorAction SilentlyContinue | Get-ChildItem -Include *.ps1 -File -ErrorAction SilentlyContinue | where-object {$_.Extension -eq '.ps1'} ) ;

if( ($psversiontable.psversion.major -lt 3) -AND ($Psv2PublicExcl -OR $Psv2PrivateExcl)){
    write-host "Powershell v2 detected: removing deprecated non-Psv2-compatible functions from module" ;
    $deprecated = $public |?{$Psv2PublicExcl -contains $_.name} ;
    $Public = $public |?{$Psv2PublicExcl -notcontains $_.name} ;
    write-verbose "(Public:skipping load of incompatible modules:$($deprecated))" ;
    #write-verbose "(not loading incompatible modules:$($deprecated))" ;
    $deprecated = $Private |?{$Psv2PrivateExcl -contains $_.name} ;
    write-verbose "(Private:skipping load of incompatible modules:$($deprecated))" ;
    $Private = $Private |?{$Psv2PrivateExcl -notcontains $_.name} ;
} ;
#Dot source the files
Foreach($import in @($Public + $Private)) {
    Try {
      . $import.fullname ;
    } catch {
      $smsg = "Failed to import function $($import.fullname): $_" ;
      $smsg += "`n$($_.exception.message)" ;
      Write-Error -Message $smsg
    } ;
}  # loop-E; ;
# another approach:
# $public + $private | Resolve-Path | %{. $_.ProviderPath}

#*======^ END FUNCTIONS ^======

<# You can also use the NestedModules key in your manifest to add all of the PS1 files using relative paths to the manifest.
I'm always wary of using the looping code that simply loads every PS1 file in a folder / subfolders. But it is a very common way of doing it.
#>
# Here I might...
# Read in or create an initial config file and variable
# Export Public functions ($Public.BaseName) for WIP modules
# Set variables visible to the module and its functions only
Export-ModuleMember -Function $Public.Basename ;

